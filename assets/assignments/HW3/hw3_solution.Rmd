---
title: "HW3 Solution"
author: "Rick Farouni"
date: "Oct 1st, 2016"
output: html_document
geometry: margin=0.5in, voffset=0in
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA)
options(digits = 3)
```

Load required libraries
```{r , message=FALSE}
library(lavaan)
library(semPlot)
```


### EX 1 (a + b) 

The following explanation contains material that wasn't covered at the time when the assignment was handed out, but you should pay attention to it since it provides a big picture for all the models that will be covered in the course. 

Consider the **structural model** (without intercept)
$$\begin{aligned}
\boldsymbol \eta &=\mathbf B \boldsymbol \eta +\boldsymbol \Gamma  \boldsymbol\xi +\boldsymbol \zeta\\
\end{aligned}
$$
and the **measurement model** 
$$\begin{aligned}
\mathbf x &=\boldsymbol \Lambda_x \boldsymbol \eta  +\boldsymbol \epsilon\\
\mathbf y &=\boldsymbol \Lambda_y \boldsymbol \xi  +\boldsymbol \delta\\
\end{aligned}
$$
where $\boldsymbol \eta$ is a vector of endogenous latent variables, $\boldsymbol\xi$ a vector of exogenous latent variables, $\boldsymbol \zeta$ is a vector error variables, $\mathbf y$ a vector of endogenous observed variables, $\mathbf x$ a vector of exogenous observed variables such that
$$\begin{aligned}
Cov(\boldsymbol \eta) &= \boldsymbol \Phi \\
Cov(\boldsymbol\xi) &= \boldsymbol \Psi \\
Cov(\boldsymbol \epsilon) &= \boldsymbol \Theta_x\\
Cov(\boldsymbol \delta) &= \boldsymbol \Theta_y
\end{aligned}
$$
Now a **path analysis model** is a structural equation model where $\mathbf x$ and $\mathbf y$ are observed without error such that 
$$\begin{aligned}
\boldsymbol \Lambda_x &=\mathbf I\\
\boldsymbol \Lambda_y &= \mathbf  I \\
\boldsymbol \Theta_x &= \boldsymbol{0} \\
\boldsymbol \Theta_y &= \boldsymbol{0}
\end{aligned} 
$$

We can use the *lisrelModel* function (one way to find out about it is through a Google search. Look [here](http://sachaepskamp.com/semPlot/examples) for examples) in the *semPlot* package to plot the path diagram for the model. We just need to feed the function the matrices with a 1 specifiying a free parameter and zero for fixed parameter. Here is the code:
```{r }
endogen_N <- 3 # number of endogenous observed variables
exogen_N <- 1 # number of exogenous observed variables
# Beta 3x3 matrix:
Beta <- matrix(c(0, 0, 0,
                 1, 0, 0,
                 1, 1, 0), 
                nrow = endogen_N,
                ncol = endogen_N,
                byrow = TRUE)

# Gamma 3x1 matrix :
Gamma <- matrix(c(1, 1, 1), 
                nrow = endogen_N , 
                ncol = exogen_N )

# Psi 3x3 diagonal matrix :
Psi <- diag(1, 
            nrow = endogen_N, 
            ncol = endogen_N)

# Phi 1x1 diagonal matrix :
Phi <- diag(1, 1, 1)

# Lambda identity matrices :
Lambda_x <- diag(1, exogen_N, exogen_N)
Lambda_y <- diag(1, endogen_N, endogen_N)

# Combine model:
mod <- lisrelModel(LY = Lambda_y,
                   PS = Psi, 
                   BE = Beta, 
                   manNamesEndo = c("IQ", "nAch", "GPA"),
                   LX = Lambda_x,
                   PH = Phi, 
                   GA = Gamma,
                   manNamesExo = "SES")
```

We can print out the matrices first
```{r }
Beta
Gamma
Psi
Phi
Lambda_x
Lambda_y
```

Here is the plot. Do you notice something unusual about the graph?
```{r }


# Plot path diagram:
semPaths(mod, 
         as.expression = c("nodes", "edges"), 
         sizeMan = 5,  # adjust size of boxes
         sizeInt = 1, 
         sizeLat = 4)
```


Alternatively, we can plot a simplified path diagram without Greek letters like this
```{r }
# Specify model
SES_model <- '
   # regressions
     IQ ~ SES
     nAch ~ SES + IQ
     GPA ~ SES + IQ + nAch '

semPaths(SES_model ,
         "eq",
         layout = "tree")

```


### EX 1 (c) 

First assign the summarized data to a character vector and convert it to a full symmetric covariance/correlation matrix with names

```{r }
# SES, IQ and Need Achievement data

SES_lower <- '
 1
.30   1
.41 .16   1
.33 .57 .50   1'

# Sample size
N3 <- 306
SES_cor <- getCov(SES_lower,
                  names = c("SES", "IQ", "nAch", "GPA"))
```

Fit the model 
```{r }
SES_model_fit <- sem(SES_model,
           sample.cov = SES_cor,
           sample.nobs = N3)

```

Print a summary of the model estimates. Don't forget to add the *rsquare* option to print out the squared multiple correlations. We can also output the list of model matrices.

```{r }
summary(SES_model_fit , rsquare = TRUE)
(modelEst1 <- lavInspect(SES_model_fit, "est"))
```

Note that in lavaan the psi matrix corresponds to the following compound matrix in the notes 

$$
\begin{bmatrix}
\boldsymbol \Psi  & \mathbf 0\\ 
\mathbf 0 & \boldsymbol \Phi
\end{bmatrix}
$$

and the beta matrix to 

$$
\begin{bmatrix}
\mathbf B  & \boldsymbol \Gamma\\ 
\mathbf 0 & \mathbf 0
\end{bmatrix}
$$

This is how to extract them
```{r }
(Psi   <- modelEst1$psi[1:3, 1:3])
(Phi   <- modelEst1$psi[4, 4])
(Beta  <- modelEst1$beta[1:3, 1:3])
(Gamma <- modelEst1$beta[1:3, 4])
```

## EX 2


Assign the summarized data to a character vector

```{r }
# Social status, actual and perceived income data
income_lower <- '
 1.0000 
 0.3670  1.0000 
 0.5103  0.4310  1.0000 
 0.3633  0.1840  0.2772  1.0000 
 0.1574  0.2819  0.2311  0.2921  1.0000' 

# Sample size
N4 <- 432

```

Convert to a full symmetric covariance/correlation matrix with names

```{r }
income_cor <- getCov(income_lower,
                       names = c("subj_income",
                                 "subj_prestige",
                                 "subj_status",
                                 "actual_income",
                                 "actual_prestige"))
```

Specify model
```{r }
income_model <- '
   # regressions
     subj_income ~ actual_income + subj_prestige
     subj_prestige ~ actual_prestige + subj_income
     subj_status ~ subj_income + subj_prestige
   # correlations
     actual_income ~~ actual_prestige
     subj_income ~~ subj_prestige 
     subj_status  ~~ subj_prestige
     subj_status  ~~ subj_income'
```

Note that the "*actual_income ~~ actual_prestige*" is not really needed. Do you know why?(hint: think regression). Now, we can fit the model and print a summary of the model estimates.

```{r }
income_model_fit <- sem(income_model,
           sample.cov = income_cor,
           sample.nobs = N4)

summary(income_model_fit,
        rsquare = TRUE)

```

We can also output a list of model matrices
```{r }
(modelEst2 <- lavInspect(income_model_fit, "est"))

```


Note that in lavaan the psi matrix corresponds to the following compound matrix in the notes 

$$
\begin{bmatrix}
\boldsymbol \Psi  & \mathbf 0\\ 
\mathbf 0 & \boldsymbol \Phi
\end{bmatrix}
$$

and the beta matrix to 

$$
\begin{bmatrix}
\mathbf B  & \boldsymbol \Gamma\\ 
\mathbf 0 & \mathbf 0
\end{bmatrix}
$$

This is how to extract them
```{r }
(Psi   <- modelEst2$psi[1:3, 1:3])
(Phi   <- modelEst2$psi[4:5, 4:5])
(Beta  <- modelEst2$beta[1:3, 1:3])
(Gamma <- modelEst2$beta[1:3, 4:5])
```

Plot the path diagram
```{r }
semPaths(income_model_fit,
         "par",
         layout = "circle")
```


